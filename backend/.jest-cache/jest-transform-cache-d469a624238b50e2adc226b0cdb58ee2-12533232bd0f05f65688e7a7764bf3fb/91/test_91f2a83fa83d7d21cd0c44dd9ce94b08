2788e762a0d8d40ff080ca692ed11b15
'use strict';

/**
 * Module dependencies.
 */
const {
  inspect
} = require('util');
const http = require('http');
const {
  STATUS_CODES
} = require('http');
const {
  Server
} = require('tls');
const {
  deepStrictEqual
} = require('assert');
const {
  Request
} = require('superagent');
let http2;
try {
  http2 = require('http2'); // eslint-disable-line global-require
} catch (_) {
  // eslint-disable-line no-empty
}

/** @typedef {import('superagent').Response} Response */

class Test extends Request {
  /**
   * Initialize a new `Test` with the given `app`,
   * request `method` and `path`.
   *
   * @param {Server} app
   * @param {String} method
   * @param {String} path
   * @api public
   */
  constructor(app, method, path, optHttp2) {
    super(method.toUpperCase(), path);
    if (typeof app === 'function') {
      if (optHttp2) {
        app = http2.createServer(app); // eslint-disable-line no-param-reassign
      } else {
        app = http.createServer(app); // eslint-disable-line no-param-reassign
      }
    }
    this.redirects(0);
    this.buffer();
    this.app = app;
    this._asserts = [];
    this.url = typeof app === 'string' ? app + path : this.serverAddress(app, path);
  }

  /**
   * Returns a URL, extracted from a server.
   *
   * @param {Server} app
   * @param {String} path
   * @returns {String} URL address
   * @api private
   */
  serverAddress(app, path) {
    const addr = app.address();
    if (!addr) this._server = app.listen(0);
    // } else {
    //   this._server = app;
    // }
    const port = app.address().port;
    const protocol = app instanceof Server ? 'https' : 'http';
    return protocol + '://127.0.0.1:' + port + path;
  }

  /**
   * Expectations:
   *
   *   .expect(200)
   *   .expect(200, fn)
   *   .expect(200, body)
   *   .expect('Some body')
   *   .expect('Some body', fn)
   *   .expect(['json array body', { key: 'val' }])
   *   .expect('Content-Type', 'application/json')
   *   .expect('Content-Type', 'application/json', fn)
   *   .expect(fn)
   *   .expect([200, 404])
   *
   * @return {Test}
   * @api public
   */
  expect(a, b, c) {
    // callback
    if (typeof a === 'function') {
      this._asserts.push(wrapAssertFn(a));
      return this;
    }
    if (typeof b === 'function') this.end(b);
    if (typeof c === 'function') this.end(c);

    // status
    if (typeof a === 'number') {
      this._asserts.push(wrapAssertFn(this._assertStatus.bind(this, a)));
      // body
      if (typeof b !== 'function' && arguments.length > 1) {
        this._asserts.push(wrapAssertFn(this._assertBody.bind(this, b)));
      }
      return this;
    }

    // multiple statuses
    if (Array.isArray(a) && a.length > 0 && a.every(val => typeof val === 'number')) {
      this._asserts.push(wrapAssertFn(this._assertStatusArray.bind(this, a)));
      return this;
    }

    // header field
    if (typeof b === 'string' || typeof b === 'number' || b instanceof RegExp) {
      this._asserts.push(wrapAssertFn(this._assertHeader.bind(this, {
        name: '' + a,
        value: b
      })));
      return this;
    }

    // body
    this._asserts.push(wrapAssertFn(this._assertBody.bind(this, a)));
    return this;
  }

  /**
   * Defer invoking superagent's `.end()` until
   * the server is listening.
   *
   * @param {?Function} fn
   * @api public
   */
  end(fn) {
    const server = this._server;
    super.end((err, res) => {
      const localAssert = () => {
        this.assert(err, res, fn);
      };
      if (server && server._handle) {
        // Handle server closing with error handling for already closed servers
        return server.close(closeError => {
          // Ignore ERR_SERVER_NOT_RUNNING errors as the server is already closed
          if (closeError && closeError.code === 'ERR_SERVER_NOT_RUNNING') {
            return localAssert();
          }
          // For other errors, pass them through
          if (closeError) {
            return localAssert();
          }
          localAssert();
        });
      }
      localAssert();
    });
    return this;
  }

  /**
   * Perform assertions and invoke `fn(err, res)`.
   *
   * @param {?Error} resError
   * @param {Response} res
   * @param {Function} fn
   * @api private
   */
  assert(resError, res, fn) {
    let errorObj;

    // check for unexpected network errors or server not running/reachable errors
    // when there is no response and superagent sends back a System Error
    // do not check further for other asserts, if any, in such case
    // https://nodejs.org/api/errors.html#errors_common_system_errors
    const sysErrors = {
      ECONNREFUSED: 'Connection refused',
      ECONNRESET: 'Connection reset by peer',
      EPIPE: 'Broken pipe',
      ETIMEDOUT: 'Operation timed out'
    };
    if (!res && resError) {
      if (resError instanceof Error && resError.syscall === 'connect' && Object.getOwnPropertyNames(sysErrors).indexOf(resError.code) >= 0) {
        errorObj = new Error(resError.code + ': ' + sysErrors[resError.code]);
      } else {
        errorObj = resError;
      }
    }

    // asserts
    for (let i = 0; i < this._asserts.length && !errorObj; i += 1) {
      errorObj = this._assertFunction(this._asserts[i], res);
    }

    // set unexpected superagent error if no other error has occurred.
    if (!errorObj && resError instanceof Error && (!res || resError.status !== res.status)) {
      errorObj = resError;
    }
    if (fn) {
      fn.call(this, errorObj || null, res);
    }
  }

  /*
    * Adds a set Authorization Bearer
    *
    * @param {Bearer} Bearer Token
    * Shortcut for .set('Authorization', `Bearer ${token}`)
    */

  bearer(token) {
    this.set('Authorization', `Bearer ${token}`);
    return this;
  }

  /*
    * Adds a set Authorization Bearer
    *
    * @param {Bearer} Bearer Token
    * Shortcut for .set('Authorization', `Bearer ${token}`)
    */

  bearer(token) {
    this.set('Authorization', `Bearer ${token}`);
    return this;
  }

  /**
   * Perform assertions on a response body and return an Error upon failure.
   *
   * @param {Mixed} body
   * @param {Response} res
   * @return {?Error}
   * @api private
   */ // eslint-disable-next-line class-methods-use-this
  _assertBody(body, res) {
    const isRegexp = body instanceof RegExp;

    // parsed
    if (typeof body === 'object' && !isRegexp) {
      try {
        deepStrictEqual(body, res.body);
      } catch (err) {
        const a = inspect(body);
        const b = inspect(res.body);
        return error('expected ' + a + ' response body, got ' + b, body, res.body);
      }
    } else if (body !== res.text) {
      // string
      const a = inspect(body);
      const b = inspect(res.text);

      // regexp
      if (isRegexp) {
        if (!body.test(res.text)) {
          return error('expected body ' + b + ' to match ' + body, body, res.body);
        }
      } else {
        return error('expected ' + a + ' response body, got ' + b, body, res.body);
      }
    }
  }

  /**
   * Perform assertions on a response header and return an Error upon failure.
   *
   * @param {Object} header
   * @param {Response} res
   * @return {?Error}
   * @api private
   */ // eslint-disable-next-line class-methods-use-this
  _assertHeader(header, res) {
    const field = header.name;
    const actual = res.header[field.toLowerCase()];
    const fieldExpected = header.value;
    if (typeof actual === 'undefined') return new Error('expected "' + field + '" header field');
    // This check handles header values that may be a String or single element Array
    if (Array.isArray(actual) && actual.toString() === fieldExpected || fieldExpected === actual) {
      return;
    }
    if (fieldExpected instanceof RegExp) {
      if (!fieldExpected.test(actual)) {
        return new Error('expected "' + field + '" matching ' + fieldExpected + ', got "' + actual + '"');
      }
    } else {
      return new Error('expected "' + field + '" of "' + fieldExpected + '", got "' + actual + '"');
    }
  }

  /**
   * Perform assertions on the response status and return an Error upon failure.
   *
   * @param {Number} status
   * @param {Response} res
   * @return {?Error}
   * @api private
   */ // eslint-disable-next-line class-methods-use-this
  _assertStatus(status, res) {
    if (res.status !== status) {
      const a = STATUS_CODES[status];
      const b = STATUS_CODES[res.status];
      return new Error('expected ' + status + ' "' + a + '", got ' + res.status + ' "' + b + '"');
    }
  }

  /**
   * Perform assertions on the response status and return an Error upon failure.
   *
   * @param {Array<Number>} statusArray
   * @param {Response} res
   * @return {?Error}
   * @api private
   */ // eslint-disable-next-line class-methods-use-this
  _assertStatusArray(statusArray, res) {
    if (!statusArray.includes(res.status)) {
      const b = STATUS_CODES[res.status];
      const expectedList = statusArray.join(', ');
      return new Error('expected one of "' + expectedList + '", got ' + res.status + ' "' + b + '"');
    }
  }

  /**
   * Performs an assertion by calling a function and return an Error upon failure.
   *
   * @param {Function} fn
   * @param {Response} res
   * @return {?Error}
   * @api private
   */ // eslint-disable-next-line class-methods-use-this
  _assertFunction(fn, res) {
    let err;
    try {
      err = fn(res);
    } catch (e) {
      err = e;
    }
    if (err instanceof Error) return err;
  }
}

/**
 * Wraps an assert function into another.
 * The wrapper function edit the stack trace of any assertion error, prepending a more useful stack to it.
 *
 * @param {Function} assertFn
 * @returns {Function} wrapped assert function
 */

function wrapAssertFn(assertFn) {
  const savedStack = new Error().stack.split('\n').slice(3);
  return function (res) {
    let badStack;
    let err;
    try {
      err = assertFn(res);
    } catch (e) {
      err = e;
    }
    if (err instanceof Error && err.stack) {
      badStack = err.stack.replace(err.message, '').split('\n').slice(1);
      err.stack = [err.toString()].concat(savedStack).concat('----').concat(badStack).join('\n');
    }
    return err;
  };
}

/**
 * Return an `Error` with `msg` and results properties.
 *
 * @param {String} msg
 * @param {Mixed} expected
 * @param {Mixed} actual
 * @return {Error}
 * @api private
 */

function error(msg, expected, actual) {
  const err = new Error(msg);
  err.expected = expected;
  err.actual = actual;
  err.showDiff = true;
  return err;
}

/**
 * Expose `Test`.
 */

module.exports = Test;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpbnNwZWN0IiwicmVxdWlyZSIsImh0dHAiLCJTVEFUVVNfQ09ERVMiLCJTZXJ2ZXIiLCJkZWVwU3RyaWN0RXF1YWwiLCJSZXF1ZXN0IiwiaHR0cDIiLCJfIiwiVGVzdCIsImNvbnN0cnVjdG9yIiwiYXBwIiwibWV0aG9kIiwicGF0aCIsIm9wdEh0dHAyIiwidG9VcHBlckNhc2UiLCJjcmVhdGVTZXJ2ZXIiLCJyZWRpcmVjdHMiLCJidWZmZXIiLCJfYXNzZXJ0cyIsInVybCIsInNlcnZlckFkZHJlc3MiLCJhZGRyIiwiYWRkcmVzcyIsIl9zZXJ2ZXIiLCJsaXN0ZW4iLCJwb3J0IiwicHJvdG9jb2wiLCJleHBlY3QiLCJhIiwiYiIsImMiLCJwdXNoIiwid3JhcEFzc2VydEZuIiwiZW5kIiwiX2Fzc2VydFN0YXR1cyIsImJpbmQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJfYXNzZXJ0Qm9keSIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwidmFsIiwiX2Fzc2VydFN0YXR1c0FycmF5IiwiUmVnRXhwIiwiX2Fzc2VydEhlYWRlciIsIm5hbWUiLCJ2YWx1ZSIsImZuIiwic2VydmVyIiwiZXJyIiwicmVzIiwibG9jYWxBc3NlcnQiLCJhc3NlcnQiLCJfaGFuZGxlIiwiY2xvc2UiLCJjbG9zZUVycm9yIiwiY29kZSIsInJlc0Vycm9yIiwiZXJyb3JPYmoiLCJzeXNFcnJvcnMiLCJFQ09OTlJFRlVTRUQiLCJFQ09OTlJFU0VUIiwiRVBJUEUiLCJFVElNRURPVVQiLCJFcnJvciIsInN5c2NhbGwiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiaW5kZXhPZiIsImkiLCJfYXNzZXJ0RnVuY3Rpb24iLCJzdGF0dXMiLCJjYWxsIiwiYmVhcmVyIiwidG9rZW4iLCJzZXQiLCJib2R5IiwiaXNSZWdleHAiLCJlcnJvciIsInRleHQiLCJ0ZXN0IiwiaGVhZGVyIiwiZmllbGQiLCJhY3R1YWwiLCJ0b0xvd2VyQ2FzZSIsImZpZWxkRXhwZWN0ZWQiLCJ0b1N0cmluZyIsInN0YXR1c0FycmF5IiwiaW5jbHVkZXMiLCJleHBlY3RlZExpc3QiLCJqb2luIiwiZSIsImFzc2VydEZuIiwic2F2ZWRTdGFjayIsInN0YWNrIiwic3BsaXQiLCJzbGljZSIsImJhZFN0YWNrIiwicmVwbGFjZSIsIm1lc3NhZ2UiLCJjb25jYXQiLCJtc2ciLCJleHBlY3RlZCIsInNob3dEaWZmIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbInRlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgeyBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgU2VydmVyIH0gPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgZGVlcFN0cmljdEVxdWFsIH0gPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IHsgUmVxdWVzdCB9ID0gcmVxdWlyZSgnc3VwZXJhZ2VudCcpO1xubGV0IGh0dHAyO1xudHJ5IHtcbiAgaHR0cDIgPSByZXF1aXJlKCdodHRwMicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG59IGNhdGNoIChfKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ3N1cGVyYWdlbnQnKS5SZXNwb25zZX0gUmVzcG9uc2UgKi9cblxuY2xhc3MgVGVzdCBleHRlbmRzIFJlcXVlc3Qge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBgVGVzdGAgd2l0aCB0aGUgZ2l2ZW4gYGFwcGAsXG4gICAqIHJlcXVlc3QgYG1ldGhvZGAgYW5kIGBwYXRoYC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2ZXJ9IGFwcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXBwLCBtZXRob2QsIHBhdGgsIG9wdEh0dHAyKSB7XG4gICAgc3VwZXIobWV0aG9kLnRvVXBwZXJDYXNlKCksIHBhdGgpO1xuXG4gICAgaWYgKHR5cGVvZiBhcHAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvcHRIdHRwMikge1xuICAgICAgICBhcHAgPSBodHRwMi5jcmVhdGVTZXJ2ZXIoYXBwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwID0gaHR0cC5jcmVhdGVTZXJ2ZXIoYXBwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVkaXJlY3RzKDApO1xuICAgIHRoaXMuYnVmZmVyKCk7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5fYXNzZXJ0cyA9IFtdO1xuICAgIHRoaXMudXJsID0gdHlwZW9mIGFwcCA9PT0gJ3N0cmluZydcbiAgICAgID8gYXBwICsgcGF0aFxuICAgICAgOiB0aGlzLnNlcnZlckFkZHJlc3MoYXBwLCBwYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgVVJMLCBleHRyYWN0ZWQgZnJvbSBhIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2ZXJ9IGFwcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBVUkwgYWRkcmVzc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNlcnZlckFkZHJlc3MoYXBwLCBwYXRoKSB7XG4gICAgY29uc3QgYWRkciA9IGFwcC5hZGRyZXNzKCk7XG5cbiAgICBpZiAoIWFkZHIpIHRoaXMuX3NlcnZlciA9IGFwcC5saXN0ZW4oMCk7XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIHRoaXMuX3NlcnZlciA9IGFwcDtcbiAgICAvLyB9XG4gICAgY29uc3QgcG9ydCA9IGFwcC5hZGRyZXNzKCkucG9ydDtcbiAgICBjb25zdCBwcm90b2NvbCA9IGFwcCBpbnN0YW5jZW9mIFNlcnZlciA/ICdodHRwcycgOiAnaHR0cCc7XG4gICAgcmV0dXJuIHByb3RvY29sICsgJzovLzEyNy4wLjAuMTonICsgcG9ydCArIHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogRXhwZWN0YXRpb25zOlxuICAgKlxuICAgKiAgIC5leHBlY3QoMjAwKVxuICAgKiAgIC5leHBlY3QoMjAwLCBmbilcbiAgICogICAuZXhwZWN0KDIwMCwgYm9keSlcbiAgICogICAuZXhwZWN0KCdTb21lIGJvZHknKVxuICAgKiAgIC5leHBlY3QoJ1NvbWUgYm9keScsIGZuKVxuICAgKiAgIC5leHBlY3QoWydqc29uIGFycmF5IGJvZHknLCB7IGtleTogJ3ZhbCcgfV0pXG4gICAqICAgLmV4cGVjdCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgKiAgIC5leHBlY3QoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJywgZm4pXG4gICAqICAgLmV4cGVjdChmbilcbiAgICogICAuZXhwZWN0KFsyMDAsIDQwNF0pXG4gICAqXG4gICAqIEByZXR1cm4ge1Rlc3R9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBleHBlY3QoYSwgYiwgYykge1xuICAgIC8vIGNhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9hc3NlcnRzLnB1c2god3JhcEFzc2VydEZuKGEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGIgPT09ICdmdW5jdGlvbicpIHRoaXMuZW5kKGIpO1xuICAgIGlmICh0eXBlb2YgYyA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5lbmQoYyk7XG5cbiAgICAvLyBzdGF0dXNcbiAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9hc3NlcnRzLnB1c2god3JhcEFzc2VydEZuKHRoaXMuX2Fzc2VydFN0YXR1cy5iaW5kKHRoaXMsIGEpKSk7XG4gICAgICAvLyBib2R5XG4gICAgICBpZiAodHlwZW9mIGIgIT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0cy5wdXNoKHdyYXBBc3NlcnRGbih0aGlzLl9hc3NlcnRCb2R5LmJpbmQodGhpcywgYikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIG11bHRpcGxlIHN0YXR1c2VzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgYS5sZW5ndGggPiAwICYmIGEuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSkge1xuICAgICAgdGhpcy5fYXNzZXJ0cy5wdXNoKHdyYXBBc3NlcnRGbih0aGlzLl9hc3NlcnRTdGF0dXNBcnJheS5iaW5kKHRoaXMsIGEpKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBoZWFkZXIgZmllbGRcbiAgICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnbnVtYmVyJyB8fCBiIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICB0aGlzLl9hc3NlcnRzLnB1c2god3JhcEFzc2VydEZuKHRoaXMuX2Fzc2VydEhlYWRlci5iaW5kKHRoaXMsIHsgbmFtZTogJycgKyBhLCB2YWx1ZTogYiB9KSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYm9keVxuICAgIHRoaXMuX2Fzc2VydHMucHVzaCh3cmFwQXNzZXJ0Rm4odGhpcy5fYXNzZXJ0Qm9keS5iaW5kKHRoaXMsIGEpKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZlciBpbnZva2luZyBzdXBlcmFnZW50J3MgYC5lbmQoKWAgdW50aWxcbiAgICogdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBmblxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgZW5kKGZuKSB7XG4gICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgc3VwZXIuZW5kKChlcnIsIHJlcykgPT4ge1xuICAgICAgY29uc3QgbG9jYWxBc3NlcnQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KGVyciwgcmVzLCBmbik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VydmVyICYmIHNlcnZlci5faGFuZGxlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzZXJ2ZXIgY2xvc2luZyB3aXRoIGVycm9yIGhhbmRsaW5nIGZvciBhbHJlYWR5IGNsb3NlZCBzZXJ2ZXJzXG4gICAgICAgIHJldHVybiBzZXJ2ZXIuY2xvc2UoKGNsb3NlRXJyb3IpID0+IHtcbiAgICAgICAgICAvLyBJZ25vcmUgRVJSX1NFUlZFUl9OT1RfUlVOTklORyBlcnJvcnMgYXMgdGhlIHNlcnZlciBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgIGlmIChjbG9zZUVycm9yICYmIGNsb3NlRXJyb3IuY29kZSA9PT0gJ0VSUl9TRVJWRVJfTk9UX1JVTk5JTkcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxBc3NlcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRm9yIG90aGVyIGVycm9ycywgcGFzcyB0aGVtIHRocm91Z2hcbiAgICAgICAgICBpZiAoY2xvc2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsQXNzZXJ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2FsQXNzZXJ0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBsb2NhbEFzc2VydCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhc3NlcnRpb25zIGFuZCBpbnZva2UgYGZuKGVyciwgcmVzKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7P0Vycm9yfSByZXNFcnJvclxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhc3NlcnQocmVzRXJyb3IsIHJlcywgZm4pIHtcbiAgICBsZXQgZXJyb3JPYmo7XG5cbiAgICAvLyBjaGVjayBmb3IgdW5leHBlY3RlZCBuZXR3b3JrIGVycm9ycyBvciBzZXJ2ZXIgbm90IHJ1bm5pbmcvcmVhY2hhYmxlIGVycm9yc1xuICAgIC8vIHdoZW4gdGhlcmUgaXMgbm8gcmVzcG9uc2UgYW5kIHN1cGVyYWdlbnQgc2VuZHMgYmFjayBhIFN5c3RlbSBFcnJvclxuICAgIC8vIGRvIG5vdCBjaGVjayBmdXJ0aGVyIGZvciBvdGhlciBhc3NlcnRzLCBpZiBhbnksIGluIHN1Y2ggY2FzZVxuICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXJyb3JzLmh0bWwjZXJyb3JzX2NvbW1vbl9zeXN0ZW1fZXJyb3JzXG4gICAgY29uc3Qgc3lzRXJyb3JzID0ge1xuICAgICAgRUNPTk5SRUZVU0VEOiAnQ29ubmVjdGlvbiByZWZ1c2VkJyxcbiAgICAgIEVDT05OUkVTRVQ6ICdDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXInLFxuICAgICAgRVBJUEU6ICdCcm9rZW4gcGlwZScsXG4gICAgICBFVElNRURPVVQ6ICdPcGVyYXRpb24gdGltZWQgb3V0J1xuICAgIH07XG5cbiAgICBpZiAoIXJlcyAmJiByZXNFcnJvcikge1xuICAgICAgaWYgKHJlc0Vycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgcmVzRXJyb3Iuc3lzY2FsbCA9PT0gJ2Nvbm5lY3QnXG4gICAgICAgICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN5c0Vycm9ycykuaW5kZXhPZihyZXNFcnJvci5jb2RlKSA+PSAwKSB7XG4gICAgICAgIGVycm9yT2JqID0gbmV3IEVycm9yKHJlc0Vycm9yLmNvZGUgKyAnOiAnICsgc3lzRXJyb3JzW3Jlc0Vycm9yLmNvZGVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yT2JqID0gcmVzRXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXNzZXJ0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXNzZXJ0cy5sZW5ndGggJiYgIWVycm9yT2JqOyBpICs9IDEpIHtcbiAgICAgIGVycm9yT2JqID0gdGhpcy5fYXNzZXJ0RnVuY3Rpb24odGhpcy5fYXNzZXJ0c1tpXSwgcmVzKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdW5leHBlY3RlZCBzdXBlcmFnZW50IGVycm9yIGlmIG5vIG90aGVyIGVycm9yIGhhcyBvY2N1cnJlZC5cbiAgICBpZiAoIWVycm9yT2JqICYmIHJlc0Vycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgKCFyZXMgfHwgcmVzRXJyb3Iuc3RhdHVzICE9PSByZXMuc3RhdHVzKSkge1xuICAgICAgZXJyb3JPYmogPSByZXNFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoZm4pIHtcbiAgICAgIGZuLmNhbGwodGhpcywgZXJyb3JPYmogfHwgbnVsbCwgcmVzKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgICogQWRkcyBhIHNldCBBdXRob3JpemF0aW9uIEJlYXJlclxuICAgICpcbiAgICAqIEBwYXJhbSB7QmVhcmVyfSBCZWFyZXIgVG9rZW5cbiAgICAqIFNob3J0Y3V0IGZvciAuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke3Rva2VufWApXG4gICAgKi9cblxuICBiZWFyZXIodG9rZW4pIHtcbiAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qXG4gICAgKiBBZGRzIGEgc2V0IEF1dGhvcml6YXRpb24gQmVhcmVyXG4gICAgKlxuICAgICogQHBhcmFtIHtCZWFyZXJ9IEJlYXJlciBUb2tlblxuICAgICogU2hvcnRjdXQgZm9yIC5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7dG9rZW59YClcbiAgICAqL1xuXG4gIGJlYXJlcih0b2tlbikge1xuICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke3Rva2VufWApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYXNzZXJ0aW9ucyBvbiBhIHJlc3BvbnNlIGJvZHkgYW5kIHJldHVybiBhbiBFcnJvciB1cG9uIGZhaWx1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGJvZHlcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gICAqIEByZXR1cm4gez9FcnJvcn1cbiAgICogQGFwaSBwcml2YXRlXG4gICAqLy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIF9hc3NlcnRCb2R5KGJvZHksIHJlcykge1xuICAgIGNvbnN0IGlzUmVnZXhwID0gYm9keSBpbnN0YW5jZW9mIFJlZ0V4cDtcblxuICAgIC8vIHBhcnNlZFxuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ29iamVjdCcgJiYgIWlzUmVnZXhwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWVwU3RyaWN0RXF1YWwoYm9keSwgcmVzLmJvZHkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGEgPSBpbnNwZWN0KGJvZHkpO1xuICAgICAgICBjb25zdCBiID0gaW5zcGVjdChyZXMuYm9keSk7XG4gICAgICAgIHJldHVybiBlcnJvcignZXhwZWN0ZWQgJyArIGEgKyAnIHJlc3BvbnNlIGJvZHksIGdvdCAnICsgYiwgYm9keSwgcmVzLmJvZHkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm9keSAhPT0gcmVzLnRleHQpIHtcbiAgICAgIC8vIHN0cmluZ1xuICAgICAgY29uc3QgYSA9IGluc3BlY3QoYm9keSk7XG4gICAgICBjb25zdCBiID0gaW5zcGVjdChyZXMudGV4dCk7XG5cbiAgICAgIC8vIHJlZ2V4cFxuICAgICAgaWYgKGlzUmVnZXhwKSB7XG4gICAgICAgIGlmICghYm9keS50ZXN0KHJlcy50ZXh0KSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcignZXhwZWN0ZWQgYm9keSAnICsgYiArICcgdG8gbWF0Y2ggJyArIGJvZHksIGJvZHksIHJlcy5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKCdleHBlY3RlZCAnICsgYSArICcgcmVzcG9uc2UgYm9keSwgZ290ICcgKyBiLCBib2R5LCByZXMuYm9keSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYXNzZXJ0aW9ucyBvbiBhIHJlc3BvbnNlIGhlYWRlciBhbmQgcmV0dXJuIGFuIEVycm9yIHVwb24gZmFpbHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAgICogQHJldHVybiB7P0Vycm9yfVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgX2Fzc2VydEhlYWRlcihoZWFkZXIsIHJlcykge1xuICAgIGNvbnN0IGZpZWxkID0gaGVhZGVyLm5hbWU7XG4gICAgY29uc3QgYWN0dWFsID0gcmVzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgICBjb25zdCBmaWVsZEV4cGVjdGVkID0gaGVhZGVyLnZhbHVlO1xuXG4gICAgaWYgKHR5cGVvZiBhY3R1YWwgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbmV3IEVycm9yKCdleHBlY3RlZCBcIicgKyBmaWVsZCArICdcIiBoZWFkZXIgZmllbGQnKTtcbiAgICAvLyBUaGlzIGNoZWNrIGhhbmRsZXMgaGVhZGVyIHZhbHVlcyB0aGF0IG1heSBiZSBhIFN0cmluZyBvciBzaW5nbGUgZWxlbWVudCBBcnJheVxuICAgIGlmICgoQXJyYXkuaXNBcnJheShhY3R1YWwpICYmIGFjdHVhbC50b1N0cmluZygpID09PSBmaWVsZEV4cGVjdGVkKVxuICAgICAgfHwgZmllbGRFeHBlY3RlZCA9PT0gYWN0dWFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmaWVsZEV4cGVjdGVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBpZiAoIWZpZWxkRXhwZWN0ZWQudGVzdChhY3R1YWwpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4cGVjdGVkIFwiJyArIGZpZWxkICsgJ1wiIG1hdGNoaW5nICdcbiAgICAgICAgICArIGZpZWxkRXhwZWN0ZWQgKyAnLCBnb3QgXCInICsgYWN0dWFsICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4cGVjdGVkIFwiJyArIGZpZWxkICsgJ1wiIG9mIFwiJyArIGZpZWxkRXhwZWN0ZWQgKyAnXCIsIGdvdCBcIicgKyBhY3R1YWwgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhc3NlcnRpb25zIG9uIHRoZSByZXNwb25zZSBzdGF0dXMgYW5kIHJldHVybiBhbiBFcnJvciB1cG9uIGZhaWx1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gICAqIEByZXR1cm4gez9FcnJvcn1cbiAgICogQGFwaSBwcml2YXRlXG4gICAqLy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIF9hc3NlcnRTdGF0dXMoc3RhdHVzLCByZXMpIHtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gc3RhdHVzKSB7XG4gICAgICBjb25zdCBhID0gU1RBVFVTX0NPREVTW3N0YXR1c107XG4gICAgICBjb25zdCBiID0gU1RBVFVTX0NPREVTW3Jlcy5zdGF0dXNdO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignZXhwZWN0ZWQgJyArIHN0YXR1cyArICcgXCInICsgYSArICdcIiwgZ290ICcgKyByZXMuc3RhdHVzICsgJyBcIicgKyBiICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYXNzZXJ0aW9ucyBvbiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGFuZCByZXR1cm4gYW4gRXJyb3IgdXBvbiBmYWlsdXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHN0YXR1c0FycmF5XG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICAgKiBAcmV0dXJuIHs/RXJyb3J9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi8vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBfYXNzZXJ0U3RhdHVzQXJyYXkoc3RhdHVzQXJyYXksIHJlcykge1xuICAgIGlmICghc3RhdHVzQXJyYXkuaW5jbHVkZXMocmVzLnN0YXR1cykpIHtcbiAgICAgIGNvbnN0IGIgPSBTVEFUVVNfQ09ERVNbcmVzLnN0YXR1c107XG4gICAgICBjb25zdCBleHBlY3RlZExpc3QgPSBzdGF0dXNBcnJheS5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgJ2V4cGVjdGVkIG9uZSBvZiBcIicgKyBleHBlY3RlZExpc3QgKyAnXCIsIGdvdCAnICsgcmVzLnN0YXR1cyArICcgXCInICsgYiArICdcIidcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGFuIGFzc2VydGlvbiBieSBjYWxsaW5nIGEgZnVuY3Rpb24gYW5kIHJldHVybiBhbiBFcnJvciB1cG9uIGZhaWx1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICAgKiBAcmV0dXJuIHs/RXJyb3J9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi8vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBfYXNzZXJ0RnVuY3Rpb24oZm4sIHJlcykge1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGVyciA9IGZuKHJlcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYW4gYXNzZXJ0IGZ1bmN0aW9uIGludG8gYW5vdGhlci5cbiAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIGVkaXQgdGhlIHN0YWNrIHRyYWNlIG9mIGFueSBhc3NlcnRpb24gZXJyb3IsIHByZXBlbmRpbmcgYSBtb3JlIHVzZWZ1bCBzdGFjayB0byBpdC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NlcnRGblxuICogQHJldHVybnMge0Z1bmN0aW9ufSB3cmFwcGVkIGFzc2VydCBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIHdyYXBBc3NlcnRGbihhc3NlcnRGbikge1xuICBjb25zdCBzYXZlZFN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDMpO1xuXG4gIHJldHVybiBmdW5jdGlvbihyZXMpIHtcbiAgICBsZXQgYmFkU3RhY2s7XG4gICAgbGV0IGVycjtcbiAgICB0cnkge1xuICAgICAgZXJyID0gYXNzZXJ0Rm4ocmVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLnN0YWNrKSB7XG4gICAgICBiYWRTdGFjayA9IGVyci5zdGFjay5yZXBsYWNlKGVyci5tZXNzYWdlLCAnJykuc3BsaXQoJ1xcbicpLnNsaWNlKDEpO1xuICAgICAgZXJyLnN0YWNrID0gW2Vyci50b1N0cmluZygpXVxuICAgICAgICAuY29uY2F0KHNhdmVkU3RhY2spXG4gICAgICAgIC5jb25jYXQoJy0tLS0nKVxuICAgICAgICAuY29uY2F0KGJhZFN0YWNrKVxuICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiBlcnI7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgd2l0aCBgbXNnYCBhbmQgcmVzdWx0cyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcbiAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZXJyb3IobXNnLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgZXJyLmFjdHVhbCA9IGFjdHVhbDtcbiAgZXJyLnNob3dEaWZmID0gdHJ1ZTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYFRlc3RgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVGVzdDtcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFFQSxNQUFNO0VBQUVBO0FBQVEsQ0FBQyxHQUFHQyxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQ25DLE1BQU1DLElBQUksR0FBR0QsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUM1QixNQUFNO0VBQUVFO0FBQWEsQ0FBQyxHQUFHRixPQUFPLENBQUMsTUFBTSxDQUFDO0FBQ3hDLE1BQU07RUFBRUc7QUFBTyxDQUFDLEdBQUdILE9BQU8sQ0FBQyxLQUFLLENBQUM7QUFDakMsTUFBTTtFQUFFSTtBQUFnQixDQUFDLEdBQUdKLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDN0MsTUFBTTtFQUFFSztBQUFRLENBQUMsR0FBR0wsT0FBTyxDQUFDLFlBQVksQ0FBQztBQUN6QyxJQUFJTSxLQUFLO0FBQ1QsSUFBSTtFQUNGQSxL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